/*
問題

n個の互いに区別できない品物を、m個以下に分割する方法の総数を求め、
Mで割った余りを求めよ。
1 <= m <= n <= 1000
2 <= M <= 10000
*/



/*
考察

自然数 n を k 個の 0 以上の整数の和で表す場合の数 (順序が異なるものは同一視) に等しいことが分かる。n = 5, k = 3 であれば、
0 + 0 + 5 = 0 + 1 + 4 = 0 + 2 + 3 = 1 + 1 + 3 = 1 + 2 + 2
の 5 通りの表し方がある。 この場合の数を P(n, k) と置く。

Q(n, k)  
= (n を k 個の 1 以上の整数に分割する場合の数)  
= (n - k を k 個の 0 以上の整数に分割する場合の数)  
= P(n-k, k)  

n を k 個の 0 以上の整数の和へと分割する方法のうち
0 を含むもの:
0 が何個あるかはわからないが、そのうちの 1 個の 0 を取り除いてしまってもよくて、
残りの k - 1 個の 0 以上の整数の和で n を表す方法を考えればよい。よって、P(n, k-1) 通り。

0 を含まないもの:
n を k 個の 1 以上の整数に分割する場合の数、つまり Q(n, k) なので、P(n-k, k) 通り。 　

以上より、P(n, k) = P(n, k-1) + P(n-k, k) が成立。



*/


#include <iostream>

using namespace std;

int n, m;
int M;
//dp[i][j]はjのi分割の総数
int dp[1010][1010];

void input()
{
    cin >> n >> m;
    cin >> M;

}

void solve()
{
    dp[0][0] = 1;
    
    for (int i = 1; i <= m; i++)
    {
        for (int j = 0; j <= n; j++)
        {
            if (j - i >= 0)
            {
                dp[i][j] = dp[i][j - i] + dp[i - 1][j] % M;
            } else {
                dp[i][j] = dp[i - 1][j];
            }
        }
    }

    cout << dp[m][n] << endl;
}

int main()
{
    input();
    solve();
}